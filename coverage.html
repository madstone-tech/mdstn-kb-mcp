
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>kbvault: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/madstone-tech/mdstn-kb-mcp/cmd/kbvault/main.go (0.0%)</option>
				
				<option value="file1">github.com/madstone-tech/mdstn-kb-mcp/pkg/types/config.go (100.0%)</option>
				
				<option value="file2">github.com/madstone-tech/mdstn-kb-mcp/pkg/types/errors.go (3.1%)</option>
				
				<option value="file3">github.com/madstone-tech/mdstn-kb-mcp/pkg/types/note.go (100.0%)</option>
				
				<option value="file4">github.com/madstone-tech/mdstn-kb-mcp/pkg/types/storage.go (0.0%)</option>
				
				<option value="file5">github.com/madstone-tech/mdstn-kb-mcp/pkg/ulid/generator.go (51.0%)</option>
				
				<option value="file6">github.com/madstone-tech/mdstn-kb-mcp/pkg/ulid/validator.go (0.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"
)

var (
        // Build information set via ldflags
        Version    = "dev"
        CommitHash = "unknown"
        BuildTime  = "unknown"
)

func main() <span class="cov0" title="0">{
        fmt.Printf("kbVault v%s\n", Version)
        fmt.Printf("Built: %s (commit: %s)\n", BuildTime, CommitHash)
        fmt.Println("\nA high-performance knowledge base vault for markdown files.")
        fmt.Println("\nFor now, this is just a placeholder. The real implementation will be built in phases:")
        fmt.Println("  Phase 1: Core Foundation &amp; CLI")
        fmt.Println("  Phase 2: Remote Storage &amp; API") 
        fmt.Println("  Phase 3: gRPC &amp; Advanced Features")
        fmt.Println("  Phase 4: MCP Integration")
        fmt.Println("  Phase 5: Polish &amp; Ecosystem")
        
        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                fmt.Printf("\nArguments passed: %v\n", os.Args[1:])
        }</span>
        
        <span class="cov0" title="0">fmt.Println("\nSee docs/PRD.md for complete specifications.")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package types

// Config represents the complete kbVault configuration
type Config struct {
        // Vault configuration
        Vault VaultConfig `toml:"vault" json:"vault"`

        // Storage backend configuration
        Storage StorageConfig `toml:"storage" json:"storage"`

        // Server configuration
        Server ServerConfig `toml:"server" json:"server"`

        // Logging configuration
        Logging LoggingConfig `toml:"logging" json:"logging"`

        // TUI configuration
        TUI TUIConfig `toml:"tui" json:"tui"`

        // MCP configuration
        MCP MCPConfig `toml:"mcp" json:"mcp"`
}

// VaultConfig contains vault-specific settings
type VaultConfig struct {
        // Name of the vault
        Name string `toml:"name" json:"name"`

        // NotesDir is the subdirectory for regular notes
        NotesDir string `toml:"notes_dir" json:"notes_dir"`

        // DailyDir is the subdirectory for daily notes
        DailyDir string `toml:"daily_dir" json:"daily_dir"`

        // TemplatesDir is the subdirectory for note templates
        TemplatesDir string `toml:"templates_dir" json:"templates_dir"`

        // DefaultTemplate is the template to use for new notes
        DefaultTemplate string `toml:"default_template" json:"default_template"`

        // MaxFileSize is the maximum allowed file size in bytes
        MaxFileSize int64 `toml:"max_file_size" json:"max_file_size"`

        // DateFormat for daily notes and timestamps
        DateFormat string `toml:"date_format" json:"date_format"`

        // TimeFormat for timestamps
        TimeFormat string `toml:"time_format" json:"time_format"`

        // AutoSave enables automatic saving of modified notes
        AutoSave bool `toml:"auto_save" json:"auto_save"`

        // AutoSync enables automatic synchronization with remote storage
        AutoSync bool `toml:"auto_sync" json:"auto_sync"`
}

// ServerConfig contains HTTP and gRPC server settings
type ServerConfig struct {
        // HTTP server configuration
        HTTP HTTPServerConfig `toml:"http" json:"http"`

        // gRPC server configuration (optional)
        GRPC GRPCServerConfig `toml:"grpc" json:"grpc"`

        // Authentication configuration
        Auth AuthConfig `toml:"auth" json:"auth"`
}

// HTTPServerConfig configures the HTTP REST API server
type HTTPServerConfig struct {
        // Enabled turns the HTTP server on/off
        Enabled bool `toml:"enabled" json:"enabled"`

        // Host to bind to
        Host string `toml:"host" json:"host"`

        // Port to listen on
        Port int `toml:"port" json:"port"`

        // EnableCORS allows cross-origin requests
        EnableCORS bool `toml:"enable_cors" json:"enable_cors"`

        // CORSOrigins specifies allowed CORS origins
        CORSOrigins []string `toml:"cors_origins" json:"cors_origins"`

        // ReadTimeout for requests (seconds)
        ReadTimeout int `toml:"read_timeout" json:"read_timeout"`

        // WriteTimeout for responses (seconds)
        WriteTimeout int `toml:"write_timeout" json:"write_timeout"`

        // IdleTimeout for idle connections (seconds)
        IdleTimeout int `toml:"idle_timeout" json:"idle_timeout"`

        // MaxRequestSize limits request body size (bytes)
        MaxRequestSize int64 `toml:"max_request_size" json:"max_request_size"`

        // TLS configuration
        TLS TLSConfig `toml:"tls" json:"tls"`
}

// GRPCServerConfig configures the gRPC server
type GRPCServerConfig struct {
        // Enabled turns the gRPC server on/off
        Enabled bool `toml:"enabled" json:"enabled"`

        // Host to bind to
        Host string `toml:"host" json:"host"`

        // Port to listen on
        Port int `toml:"port" json:"port"`

        // MaxRecvMsgSize limits incoming message size
        MaxRecvMsgSize int `toml:"max_recv_msg_size" json:"max_recv_msg_size"`

        // MaxSendMsgSize limits outgoing message size
        MaxSendMsgSize int `toml:"max_send_msg_size" json:"max_send_msg_size"`

        // ConnectionTimeout for client connections (seconds)
        ConnectionTimeout int `toml:"connection_timeout" json:"connection_timeout"`

        // TLS configuration
        TLS TLSConfig `toml:"tls" json:"tls"`

        // EnableBulkOperations enables bulk operation services
        EnableBulkOperations bool `toml:"enable_bulk_operations" json:"enable_bulk_operations"`

        // EnableCollaboration enables real-time collaboration features
        EnableCollaboration bool `toml:"enable_collaboration" json:"enable_collaboration"`

        // EnableAgentService enables AI agent-specific services
        EnableAgentService bool `toml:"enable_agent_service" json:"enable_agent_service"`
}

// TLSConfig configures TLS/SSL settings
type TLSConfig struct {
        // Enabled turns on TLS
        Enabled bool `toml:"enabled" json:"enabled"`

        // CertFile path to certificate file
        CertFile string `toml:"cert_file" json:"cert_file"`

        // KeyFile path to private key file
        KeyFile string `toml:"key_file" json:"key_file"`

        // CAFile path to CA certificate (for client cert verification)
        CAFile string `toml:"ca_file" json:"ca_file"`

        // RequireClientCert forces client certificate authentication
        RequireClientCert bool `toml:"require_client_cert" json:"require_client_cert"`
}

// AuthConfig configures authentication and authorization
type AuthConfig struct {
        // Type of authentication (none, apikey, jwt)
        Type string `toml:"type" json:"type"`

        // APIKeys for API key authentication
        APIKeys []string `toml:"api_keys" json:"api_keys"`

        // JWT configuration
        JWT JWTConfig `toml:"jwt" json:"jwt"`

        // RateLimit configuration
        RateLimit RateLimitConfig `toml:"rate_limit" json:"rate_limit"`
}

// JWTConfig configures JWT token authentication
type JWTConfig struct {
        // Secret for signing tokens
        Secret string `toml:"secret" json:"secret"`

        // Issuer for token validation
        Issuer string `toml:"issuer" json:"issuer"`

        // Audience for token validation
        Audience string `toml:"audience" json:"audience"`

        // ExpiryHours for token expiration
        ExpiryHours int `toml:"expiry_hours" json:"expiry_hours"`
}

// RateLimitConfig configures API rate limiting
type RateLimitConfig struct {
        // Enabled turns on rate limiting
        Enabled bool `toml:"enabled" json:"enabled"`

        // RequestsPerMinute limit per IP
        RequestsPerMinute int `toml:"requests_per_minute" json:"requests_per_minute"`

        // BurstSize allows temporary bursts above the rate limit
        BurstSize int `toml:"burst_size" json:"burst_size"`
}

// LoggingConfig configures application logging
type LoggingConfig struct {
        // Level sets the log level (DEBUG, INFO, WARN, ERROR)
        Level string `toml:"level" json:"level"`

        // Output destination (stdout, file, remote)
        Output string `toml:"output" json:"output"`

        // FilePath for file-based logging
        FilePath string `toml:"file_path" json:"file_path"`

        // Format for log messages (text, json)
        Format string `toml:"format" json:"format"`

        // EnableColors adds color to console output
        EnableColors bool `toml:"enable_colors" json:"enable_colors"`

        // EnableTimestamp includes timestamps in logs
        EnableTimestamp bool `toml:"enable_timestamp" json:"enable_timestamp"`

        // EnableCaller includes caller information
        EnableCaller bool `toml:"enable_caller" json:"enable_caller"`

        // RotateSize triggers log rotation at this size (MB)
        RotateSize int `toml:"rotate_size" json:"rotate_size"`

        // RotateCount is the number of old log files to keep
        RotateCount int `toml:"rotate_count" json:"rotate_count"`
}

// TUIConfig configures the terminal user interface
type TUIConfig struct {
        // Theme for the TUI (default, dark, light)
        Theme string `toml:"theme" json:"theme"`

        // VimMode enables vim-style key bindings
        VimMode bool `toml:"vim_mode" json:"vim_mode"`

        // ShowHelp displays help information
        ShowHelp bool `toml:"show_help" json:"show_help"`

        // RefreshInterval for auto-refresh (seconds)
        RefreshInterval int `toml:"refresh_interval" json:"refresh_interval"`

        // PageSize for paginated lists
        PageSize int `toml:"page_size" json:"page_size"`

        // EnableMouse allows mouse interaction
        EnableMouse bool `toml:"enable_mouse" json:"enable_mouse"`
}

// MCPConfig configures Model Context Protocol integration
type MCPConfig struct {
        // Enabled turns on MCP server
        Enabled bool `toml:"enabled" json:"enabled"`

        // SocketPath for Unix socket communication
        SocketPath string `toml:"socket_path" json:"socket_path"`

        // UseStdio uses stdin/stdout instead of socket
        UseStdio bool `toml:"use_stdio" json:"use_stdio"`

        // MaxRequestSize limits MCP request size
        MaxRequestSize int64 `toml:"max_request_size" json:"max_request_size"`

        // ResponseTimeout for MCP operations (seconds)
        ResponseTimeout int `toml:"response_timeout" json:"response_timeout"`

        // EnableBulkOperations allows bulk note operations
        EnableBulkOperations bool `toml:"enable_bulk_operations" json:"enable_bulk_operations"`

        // MaxBulkSize limits bulk operation size
        MaxBulkSize int `toml:"max_bulk_size" json:"max_bulk_size"`
}

// DefaultConfig returns a configuration with sensible defaults
func DefaultConfig() *Config <span class="cov10" title="16">{
        return &amp;Config{
                Vault: VaultConfig{
                        Name:            "my-kb",
                        NotesDir:        "notes",
                        DailyDir:        "notes/dailies",
                        TemplatesDir:    "templates",
                        DefaultTemplate: "default",
                        MaxFileSize:     10 * 1024 * 1024, // 10MB
                        DateFormat:      "2006-01-02",
                        TimeFormat:      "15:04:05",
                        AutoSave:        true,
                        AutoSync:        false,
                },
                Storage: StorageConfig{
                        Type: StorageTypeLocal,
                        Local: LocalStorageConfig{
                                Path:          "./vault",
                                CreateDirs:    true,
                                DirPerms:      "0755",
                                FilePerms:     "0644",
                                EnableLocking: true,
                                LockTimeout:   10,
                        },
                        Cache: CacheConfig{
                                Enabled:    false,
                                AutoEnable: true,
                                Memory: MemoryCacheConfig{
                                        Enabled:    true,
                                        MaxSizeMB:  100,
                                        MaxItems:   1000,
                                        TTLMinutes: 5,
                                },
                                Disk: DiskCacheConfig{
                                        Enabled:              true,
                                        Path:                 "/tmp/kbvault-cache",
                                        MaxSizeMB:            1000,
                                        TTLHours:             24,
                                        CleanupIntervalHours: 6,
                                },
                        },
                },
                Server: ServerConfig{
                        HTTP: HTTPServerConfig{
                                Enabled:        true,
                                Host:           "localhost",
                                Port:           8080,
                                EnableCORS:     true,
                                CORSOrigins:    []string{"*"},
                                ReadTimeout:    30,
                                WriteTimeout:   30,
                                IdleTimeout:    60,
                                MaxRequestSize: 10 * 1024 * 1024, // 10MB
                        },
                        GRPC: GRPCServerConfig{
                                Enabled:              false,
                                Host:                 "localhost",
                                Port:                 9090,
                                MaxRecvMsgSize:       4 * 1024 * 1024, // 4MB
                                MaxSendMsgSize:       4 * 1024 * 1024, // 4MB
                                ConnectionTimeout:    30,
                                EnableBulkOperations: false,
                                EnableCollaboration:  false,
                                EnableAgentService:   true,
                        },
                        Auth: AuthConfig{
                                Type: "none",
                                RateLimit: RateLimitConfig{
                                        Enabled:           false,
                                        RequestsPerMinute: 100,
                                        BurstSize:         10,
                                },
                        },
                },
                Logging: LoggingConfig{
                        Level:           "WARN",
                        Output:          "stdout",
                        Format:          "text",
                        EnableColors:    true,
                        EnableTimestamp: true,
                        EnableCaller:    false,
                        RotateSize:      100,
                        RotateCount:     5,
                },
                TUI: TUIConfig{
                        Theme:           "default",
                        VimMode:         false,
                        ShowHelp:        true,
                        RefreshInterval: 30,
                        PageSize:        20,
                        EnableMouse:     true,
                },
                MCP: MCPConfig{
                        Enabled:              true,
                        SocketPath:           "/tmp/kbvault.sock",
                        UseStdio:             false,
                        MaxRequestSize:       10 * 1024 * 1024, // 10MB
                        ResponseTimeout:      30,
                        EnableBulkOperations: true,
                        MaxBulkSize:          100,
                },
        }
}</span>

// Validate performs validation on the configuration
func (c *Config) Validate() error <span class="cov8" title="9">{
        // Validate vault config
        if c.Vault.Name == "" </span><span class="cov1" title="1">{
                return NewValidationError("vault name cannot be empty")
        }</span>
        <span class="cov7" title="8">if c.Vault.MaxFileSize &lt;= 0 </span><span class="cov1" title="1">{
                return NewValidationError("vault max_file_size must be positive")
        }</span>

        // Validate storage config
        <span class="cov7" title="7">if c.Storage.Type != StorageTypeLocal &amp;&amp; c.Storage.Type != StorageTypeS3 </span><span class="cov1" title="1">{
                return NewValidationError("storage type must be 'local' or 's3'")
        }</span>

        // Validate server config
        <span class="cov6" title="6">if c.Server.HTTP.Enabled </span><span class="cov6" title="6">{
                if c.Server.HTTP.Port &lt;= 0 || c.Server.HTTP.Port &gt; 65535 </span><span class="cov3" title="2">{
                        return NewValidationError("HTTP port must be between 1 and 65535")
                }</span>
        }
        <span class="cov5" title="4">if c.Server.GRPC.Enabled </span><span class="cov3" title="2">{
                if c.Server.GRPC.Port &lt;= 0 || c.Server.GRPC.Port &gt; 65535 </span><span class="cov1" title="1">{
                        return NewValidationError("gRPC port must be between 1 and 65535")
                }</span>
                <span class="cov1" title="1">if c.Server.HTTP.Enabled &amp;&amp; c.Server.HTTP.Port == c.Server.GRPC.Port </span><span class="cov1" title="1">{
                        return NewValidationError("HTTP and gRPC ports cannot be the same")
                }</span>
        }

        // Validate auth config
        <span class="cov3" title="2">if c.Server.Auth.Type != "none" &amp;&amp; c.Server.Auth.Type != "apikey" &amp;&amp; c.Server.Auth.Type != "jwt" </span><span class="cov1" title="1">{
                return NewValidationError("auth type must be 'none', 'apikey', or 'jwt'")
        }</span>

        <span class="cov1" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package types

import (
        "fmt"
)

// ErrorType represents different categories of errors
type ErrorType string

const (
        ErrorTypeValidation   ErrorType = "validation"
        ErrorTypeNotFound     ErrorType = "not_found"
        ErrorTypeConflict     ErrorType = "conflict"
        ErrorTypePermission   ErrorType = "permission"
        ErrorTypeStorage      ErrorType = "storage"
        ErrorTypeNetwork      ErrorType = "network"
        ErrorTypeTimeout      ErrorType = "timeout"
        ErrorTypeRateLimit    ErrorType = "rate_limit"
        ErrorTypeInternal     ErrorType = "internal"
        ErrorTypeUnavailable  ErrorType = "unavailable"
        ErrorTypeUnauthorized ErrorType = "unauthorized"
)

// KBError represents a structured error from kbVault operations
type KBError struct {
        Type     ErrorType `json:"type"`
        Code     string    `json:"code"`
        Message  string    `json:"message"`
        Details  string    `json:"details,omitempty"`
        Context  map[string]interface{} `json:"context,omitempty"`
        Cause    error     `json:"-"`
}

func (e *KBError) Error() string <span class="cov0" title="0">{
        if e.Details != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("[%s:%s] %s: %s", e.Type, e.Code, e.Message, e.Details)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("[%s:%s] %s", e.Type, e.Code, e.Message)</span>
}

func (e *KBError) Unwrap() error <span class="cov0" title="0">{
        return e.Cause
}</span>

// WithContext adds contextual information to the error
func (e *KBError) WithContext(key string, value interface{}) *KBError <span class="cov0" title="0">{
        if e.Context == nil </span><span class="cov0" title="0">{
                e.Context = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">e.Context[key] = value
        return e</span>
}

// WithCause sets the underlying cause of the error
func (e *KBError) WithCause(err error) *KBError <span class="cov0" title="0">{
        e.Cause = err
        return e
}</span>

// IsType checks if the error is of a specific type
func (e *KBError) IsType(errType ErrorType) bool <span class="cov0" title="0">{
        return e.Type == errType
}</span>

// IsRetryable returns true if the operation can be retried
func (e *KBError) IsRetryable() bool <span class="cov0" title="0">{
        return e.Type == ErrorTypeNetwork || e.Type == ErrorTypeTimeout || e.Type == ErrorTypeUnavailable
}</span>

// NewKBError creates a new kbVault error
func NewKBError(errType ErrorType, code, message string) *KBError <span class="cov10" title="11">{
        return &amp;KBError{
                Type:    errType,
                Code:    code,
                Message: message,
        }
}</span>

// Validation Errors
func NewValidationError(message string) *KBError <span class="cov10" title="11">{
        return NewKBError(ErrorTypeValidation, "VALIDATION_FAILED", message)
}</span>

func NewInvalidIDError(id string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeValidation, "INVALID_ID", "invalid note ID").
                WithContext("id", id)
}</span>

func NewInvalidContentError(reason string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeValidation, "INVALID_CONTENT", "invalid note content").
                WithContext("reason", reason)
}</span>

// Not Found Errors
func NewNoteNotFoundError(id string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeNotFound, "NOTE_NOT_FOUND", "note not found").
                WithContext("note_id", id)
}</span>

func NewTemplateNotFoundError(name string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeNotFound, "TEMPLATE_NOT_FOUND", "template not found").
                WithContext("template", name)
}</span>

func NewVaultNotFoundError(path string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeNotFound, "VAULT_NOT_FOUND", "vault not found").
                WithContext("path", path)
}</span>

// Conflict Errors
func NewNoteExistsError(id string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeConflict, "NOTE_EXISTS", "note already exists").
                WithContext("note_id", id)
}</span>

func NewConcurrencyConflictError(resource string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeConflict, "CONCURRENCY_CONFLICT", "concurrent modification detected").
                WithContext("resource", resource)
}</span>

// Permission Errors
func NewPermissionDeniedError(operation, resource string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypePermission, "PERMISSION_DENIED", "permission denied").
                WithContext("operation", operation).
                WithContext("resource", resource)
}</span>

func NewReadOnlyError(resource string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypePermission, "READ_ONLY", "resource is read-only").
                WithContext("resource", resource)
}</span>

// Storage Errors
func NewStorageUnavailableError(backend string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeUnavailable, "STORAGE_UNAVAILABLE", "storage backend unavailable").
                WithContext("backend", backend)
}</span>

func NewStorageConnectionError(backend string, err error) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeNetwork, "STORAGE_CONNECTION_FAILED", "failed to connect to storage").
                WithContext("backend", backend).
                WithCause(err)
}</span>

func NewStorageTimeoutError(backend, operation string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeTimeout, "STORAGE_TIMEOUT", "storage operation timed out").
                WithContext("backend", backend).
                WithContext("operation", operation)
}</span>

// Authentication/Authorization Errors
func NewUnauthorizedError(message string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeUnauthorized, "UNAUTHORIZED", message)
}</span>

func NewInvalidTokenError() *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeUnauthorized, "INVALID_TOKEN", "authentication token is invalid")
}</span>

func NewTokenExpiredError() *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeUnauthorized, "TOKEN_EXPIRED", "authentication token has expired")
}</span>

// Rate Limiting Errors
func NewRateLimitError(limit int, window string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeRateLimit, "RATE_LIMIT_EXCEEDED", "rate limit exceeded").
                WithContext("limit", limit).
                WithContext("window", window)
}</span>

// Internal Errors
func NewInternalError(message string, err error) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeInternal, "INTERNAL_ERROR", message).
                WithCause(err)
}</span>

func NewConfigurationError(message string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeInternal, "CONFIGURATION_ERROR", message)
}</span>

func NewCircuitBreakerError(service string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeUnavailable, "CIRCUIT_BREAKER_OPEN", "service temporarily unavailable").
                WithContext("service", service)
}</span>

// Service Unavailable Errors
func NewServiceUnavailableError(service string) *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeUnavailable, "SERVICE_UNAVAILABLE", "service is temporarily unavailable").
                WithContext("service", service)
}</span>

func NewMaintenanceModeError() *KBError <span class="cov0" title="0">{
        return NewKBError(ErrorTypeUnavailable, "MAINTENANCE_MODE", "system is in maintenance mode")
}</span>

// Helper functions for error checking
func IsValidationError(err error) bool <span class="cov0" title="0">{
        if kbErr, ok := err.(*KBError); ok </span><span class="cov0" title="0">{
                return kbErr.IsType(ErrorTypeValidation)
        }</span>
        <span class="cov0" title="0">return false</span>
}

func IsNotFoundError(err error) bool <span class="cov0" title="0">{
        if kbErr, ok := err.(*KBError); ok </span><span class="cov0" title="0">{
                return kbErr.IsType(ErrorTypeNotFound)
        }</span>
        <span class="cov0" title="0">return false</span>
}

func IsConflictError(err error) bool <span class="cov0" title="0">{
        if kbErr, ok := err.(*KBError); ok </span><span class="cov0" title="0">{
                return kbErr.IsType(ErrorTypeConflict)
        }</span>
        <span class="cov0" title="0">return false</span>
}

func IsRetryableError(err error) bool <span class="cov0" title="0">{
        if kbErr, ok := err.(*KBError); ok </span><span class="cov0" title="0">{
                return kbErr.IsRetryable()
        }</span>
        <span class="cov0" title="0">return false</span>
}

func IsUnauthorizedError(err error) bool <span class="cov0" title="0">{
        if kbErr, ok := err.(*KBError); ok </span><span class="cov0" title="0">{
                return kbErr.IsType(ErrorTypeUnauthorized)
        }</span>
        <span class="cov0" title="0">return false</span>
}

func IsRateLimitError(err error) bool <span class="cov0" title="0">{
        if kbErr, ok := err.(*KBError); ok </span><span class="cov0" title="0">{
                return kbErr.IsType(ErrorTypeRateLimit)
        }</span>
        <span class="cov0" title="0">return false</span>
}

// HTTPStatusCode returns the appropriate HTTP status code for the error
func (e *KBError) HTTPStatusCode() int <span class="cov0" title="0">{
        switch e.Type </span>{
        case ErrorTypeValidation:<span class="cov0" title="0">
                return 400</span> // Bad Request
        case ErrorTypeNotFound:<span class="cov0" title="0">
                return 404</span> // Not Found
        case ErrorTypeConflict:<span class="cov0" title="0">
                return 409</span> // Conflict
        case ErrorTypePermission:<span class="cov0" title="0">
                return 403</span> // Forbidden
        case ErrorTypeUnauthorized:<span class="cov0" title="0">
                return 401</span> // Unauthorized
        case ErrorTypeRateLimit:<span class="cov0" title="0">
                return 429</span> // Too Many Requests
        case ErrorTypeTimeout:<span class="cov0" title="0">
                return 408</span> // Request Timeout
        case ErrorTypeUnavailable:<span class="cov0" title="0">
                return 503</span> // Service Unavailable
        case ErrorTypeInternal:<span class="cov0" title="0">
                return 500</span> // Internal Server Error
        default:<span class="cov0" title="0">
                return 500</span> // Internal Server Error
        }
}</pre>
		
		<pre class="file" id="file3" style="display: none">package types

import (
        "time"
)

// Note represents a single knowledge base note
type Note struct {
        // ID is the ULID-based unique identifier
        ID string `json:"id" toml:"id"`

        // Title is the human-readable note title
        Title string `json:"title" toml:"title"`

        // Content is the markdown body of the note
        Content string `json:"content" toml:"content"`

        // Frontmatter contains structured metadata
        Frontmatter Frontmatter `json:"frontmatter" toml:"frontmatter"`

        // FilePath is the relative path from vault root
        FilePath string `json:"file_path" toml:"file_path"`

        // StorageBackend indicates where this note is stored
        StorageBackend StorageType `json:"storage_backend" toml:"storage_backend"`

        // CreatedAt is when the note was first created
        CreatedAt time.Time `json:"created_at" toml:"created_at"`

        // UpdatedAt is when the note was last modified
        UpdatedAt time.Time `json:"updated_at" toml:"updated_at"`

        // Size is the content size in bytes
        Size int64 `json:"size" toml:"size"`
}

// Frontmatter represents the YAML/TOML metadata at the top of notes
type Frontmatter struct {
        // ID mirrors the note ID for consistency
        ID string `json:"id" yaml:"id" toml:"id"`

        // Title mirrors the note title
        Title string `json:"title" yaml:"title" toml:"title"`

        // Tags for categorization and filtering
        Tags []string `json:"tags" yaml:"tags" toml:"tags"`

        // Type indicates the kind of note (note, daily, template, etc.)
        Type string `json:"type" yaml:"type" toml:"type"`

        // Created timestamp in ISO format
        Created string `json:"created" yaml:"created" toml:"created"`

        // Updated timestamp in ISO format  
        Updated string `json:"updated" yaml:"updated" toml:"updated"`

        // Storage backend for this note
        Storage string `json:"storage" yaml:"storage" toml:"storage"`

        // Template used to create this note
        Template string `json:"template,omitempty" yaml:"template,omitempty" toml:"template,omitempty"`

        // Custom metadata fields
        Custom map[string]interface{} `json:"custom,omitempty" yaml:"custom,omitempty" toml:"custom,omitempty"`
}

// NoteMetadata represents lightweight note information for listings
type NoteMetadata struct {
        ID             string      `json:"id"`
        Title          string      `json:"title"`
        Tags           []string    `json:"tags"`
        Type           string      `json:"type"`
        FilePath       string      `json:"file_path"`
        StorageBackend StorageType `json:"storage_backend"`
        CreatedAt      time.Time   `json:"created_at"`
        UpdatedAt      time.Time   `json:"updated_at"`
        Size           int64       `json:"size"`
}

// CreateNoteRequest represents a request to create a new note
type CreateNoteRequest struct {
        // Title for the new note (required)
        Title string `json:"title" validate:"required,max=200"`

        // Content for the note body (optional)
        Content string `json:"content,omitempty" validate:"max=10485760"` // 10MB limit

        // Tags to assign (optional)
        Tags []string `json:"tags,omitempty"`

        // Template to use (optional, defaults to "default")
        Template string `json:"template,omitempty"`

        // Type of note (optional, defaults to "note")
        Type string `json:"type,omitempty"`

        // Custom frontmatter fields (optional)
        Custom map[string]interface{} `json:"custom,omitempty"`
}

// UpdateNoteRequest represents a request to update an existing note
type UpdateNoteRequest struct {
        // ID of the note to update (required)
        ID string `json:"id" validate:"required"`

        // Title update (optional)
        Title *string `json:"title,omitempty" validate:"omitempty,max=200"`

        // Content update (optional)
        Content *string `json:"content,omitempty" validate:"omitempty,max=10485760"` // 10MB limit

        // Tags update (optional)
        Tags []string `json:"tags,omitempty"`

        // Type update (optional)
        Type *string `json:"type,omitempty"`

        // Custom frontmatter updates (optional)
        Custom map[string]interface{} `json:"custom,omitempty"`
}

// Link represents a connection between notes
type Link struct {
        // SourceID is the note containing the link
        SourceID string `json:"source_id"`

        // TargetID is the note being linked to
        TargetID string `json:"target_id"`

        // TargetTitle is the resolved title of the target note
        TargetTitle string `json:"target_title"`

        // LinkText is the display text of the link
        LinkText string `json:"link_text"`

        // Position is the character position in the source note
        Position int `json:"position"`

        // IsValid indicates if the target exists
        IsValid bool `json:"is_valid"`

        // Type of link (wiki, markdown, etc.)
        Type LinkType `json:"type"`
}

// LinkType represents the style of link
type LinkType string

const (
        LinkTypeWiki     LinkType = "wiki"     // [[Note Title]]
        LinkTypeMarkdown LinkType = "markdown" // [Link Text](note-id)
        LinkTypeID       LinkType = "id"       // [[note-id]]
)

// ToMetadata converts a Note to NoteMetadata
func (n *Note) ToMetadata() NoteMetadata <span class="cov1" title="1">{
        return NoteMetadata{
                ID:             n.ID,
                Title:          n.Title,
                Tags:           n.Frontmatter.Tags,
                Type:           n.Frontmatter.Type,
                FilePath:       n.FilePath,
                StorageBackend: n.StorageBackend,
                CreatedAt:      n.CreatedAt,
                UpdatedAt:      n.UpdatedAt,
                Size:           n.Size,
        }
}</span>

// HasTag checks if the note has a specific tag
func (n *Note) HasTag(tag string) bool <span class="cov8" title="11">{
        for _, t := range n.Frontmatter.Tags </span><span class="cov10" title="21">{
                if t == tag </span><span class="cov6" title="7">{
                        return true
                }</span>
        }
        <span class="cov5" title="4">return false</span>
}

// AddTag adds a tag to the note if it doesn't already exist
func (n *Note) AddTag(tag string) <span class="cov3" title="2">{
        if !n.HasTag(tag) </span><span class="cov1" title="1">{
                n.Frontmatter.Tags = append(n.Frontmatter.Tags, tag)
        }</span>
}

// RemoveTag removes a tag from the note
func (n *Note) RemoveTag(tag string) <span class="cov3" title="2">{
        for i, t := range n.Frontmatter.Tags </span><span class="cov5" title="4">{
                if t == tag </span><span class="cov1" title="1">{
                        n.Frontmatter.Tags = append(n.Frontmatter.Tags[:i], n.Frontmatter.Tags[i+1:]...)
                        break</span>
                }
        }
}

// IsDaily returns true if this is a daily note
func (n *Note) IsDaily() bool <span class="cov5" title="4">{
        return n.Frontmatter.Type == "daily"
}</span>

// IsTemplate returns true if this is a template note
func (n *Note) IsTemplate() bool <span class="cov5" title="4">{
        return n.Frontmatter.Type == "template"
}</span>

// Validate performs basic validation on the note
func (n *Note) Validate() error <span class="cov5" title="4">{
        if n.ID == "" </span><span class="cov1" title="1">{
                return NewValidationError("note ID cannot be empty")
        }</span>
        <span class="cov4" title="3">if n.Title == "" </span><span class="cov1" title="1">{
                return NewValidationError("note title cannot be empty")
        }</span>
        <span class="cov3" title="2">if len(n.Content) &gt; 10*1024*1024 </span><span class="cov1" title="1">{ // 10MB limit
                return NewValidationError("note content exceeds 10MB limit")
        }</span>
        <span class="cov1" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package types

import (
        "context"
        "fmt"
        "io"
)

// StorageType represents the type of storage backend
type StorageType string

const (
        StorageTypeLocal StorageType = "local"
        StorageTypeS3    StorageType = "s3"
)

// StorageBackend defines the interface for all storage implementations
type StorageBackend interface {
        // Type returns the storage backend type
        Type() StorageType

        // Read retrieves a file's content by path
        Read(ctx context.Context, path string) ([]byte, error)

        // Write stores content at the given path
        Write(ctx context.Context, path string, data []byte) error

        // Delete removes a file at the given path
        Delete(ctx context.Context, path string) error

        // Exists checks if a file exists at the given path
        Exists(ctx context.Context, path string) (bool, error)

        // List returns all files matching the given prefix
        List(ctx context.Context, prefix string) ([]string, error)

        // Stat returns metadata about a file
        Stat(ctx context.Context, path string) (*FileInfo, error)

        // ReadStream returns a reader for streaming large files
        ReadStream(ctx context.Context, path string) (io.ReadCloser, error)

        // WriteStream writes data from a reader to the given path
        WriteStream(ctx context.Context, path string, reader io.Reader) error

        // Copy copies a file from src to dst within the same backend
        Copy(ctx context.Context, src, dst string) error

        // Move moves/renames a file from src to dst
        Move(ctx context.Context, src, dst string) error

        // Health performs a health check on the storage backend
        Health(ctx context.Context) error

        // Close cleanly shuts down the storage backend
        Close() error
}

// FileInfo contains metadata about a stored file
type FileInfo struct {
        // Path is the full path to the file
        Path string `json:"path"`

        // Size is the file size in bytes
        Size int64 `json:"size"`

        // ModTime is when the file was last modified
        ModTime int64 `json:"mod_time"` // Unix timestamp

        // ETag is an entity tag for the file (for S3 compatibility)
        ETag string `json:"etag,omitempty"`

        // ContentType is the MIME type of the file
        ContentType string `json:"content_type,omitempty"`

        // StorageClass indicates the storage tier (S3 specific)
        StorageClass string `json:"storage_class,omitempty"`

        // Custom metadata from the storage backend
        Metadata map[string]string `json:"metadata,omitempty"`
}

// StorageConfig contains configuration for storage backends
type StorageConfig struct {
        // Type specifies which storage backend to use
        Type StorageType `toml:"type" json:"type"`

        // Local storage configuration
        Local LocalStorageConfig `toml:"local" json:"local"`

        // S3 storage configuration
        S3 S3StorageConfig `toml:"s3" json:"s3"`

        // Cache configuration
        Cache CacheConfig `toml:"cache" json:"cache"`
}

// LocalStorageConfig configures local filesystem storage
type LocalStorageConfig struct {
        // Path is the root directory for the vault
        Path string `toml:"path" json:"path"`

        // CreateDirs automatically creates directories if they don't exist
        CreateDirs bool `toml:"create_dirs" json:"create_dirs"`

        // Permissions for created directories (octal)
        DirPerms string `toml:"dir_perms" json:"dir_perms"`

        // Permissions for created files (octal)
        FilePerms string `toml:"file_perms" json:"file_perms"`

        // EnableLocking enables file locking for concurrent access
        EnableLocking bool `toml:"enable_locking" json:"enable_locking"`

        // LockTimeout is the maximum time to wait for a file lock (seconds)
        LockTimeout int `toml:"lock_timeout" json:"lock_timeout"`
}

// S3StorageConfig configures S3-compatible storage
type S3StorageConfig struct {
        // Bucket is the S3 bucket name
        Bucket string `toml:"bucket" json:"bucket"`

        // Region is the AWS region
        Region string `toml:"region" json:"region"`

        // Endpoint for S3-compatible services (optional)
        Endpoint string `toml:"endpoint" json:"endpoint"`

        // AccessKeyID for authentication
        AccessKeyID string `toml:"access_key_id" json:"access_key_id"`

        // SecretAccessKey for authentication
        SecretAccessKey string `toml:"secret_access_key" json:"secret_access_key"`

        // SessionToken for temporary credentials (optional)
        SessionToken string `toml:"session_token" json:"session_token"`

        // UseSSL enables HTTPS for API calls
        UseSSL bool `toml:"use_ssl" json:"use_ssl"`

        // PathStyle forces path-style addressing
        PathStyle bool `toml:"path_style" json:"path_style"`

        // Prefix for all objects in the bucket
        Prefix string `toml:"prefix" json:"prefix"`

        // StorageClass for uploaded objects
        StorageClass string `toml:"storage_class" json:"storage_class"`

        // ServerSideEncryption enables SSE
        ServerSideEncryption string `toml:"server_side_encryption" json:"server_side_encryption"`

        // KMSKeyID for SSE-KMS encryption
        KMSKeyID string `toml:"kms_key_id" json:"kms_key_id"`

        // RetryAttempts for failed operations
        RetryAttempts int `toml:"retry_attempts" json:"retry_attempts"`

        // RetryDelay base delay between retries (milliseconds)
        RetryDelay int `toml:"retry_delay" json:"retry_delay"`

        // RequestTimeout for individual requests (seconds)
        RequestTimeout int `toml:"request_timeout" json:"request_timeout"`

        // EnableVersioning enables S3 bucket versioning
        EnableVersioning bool `toml:"enable_versioning" json:"enable_versioning"`
}

// CacheConfig configures the caching layer
type CacheConfig struct {
        // Enabled turns on/off caching
        Enabled bool `toml:"enabled" json:"enabled"`

        // AutoEnable automatically enables caching for remote storage
        AutoEnable bool `toml:"auto_enable_for_remote" json:"auto_enable_for_remote"`

        // Memory cache configuration
        Memory MemoryCacheConfig `toml:"memory" json:"memory"`

        // Disk cache configuration
        Disk DiskCacheConfig `toml:"disk" json:"disk"`
}

// MemoryCacheConfig configures in-memory caching
type MemoryCacheConfig struct {
        // Enabled turns on/off memory caching
        Enabled bool `toml:"enabled" json:"enabled"`

        // MaxSizeMB is the maximum memory cache size in MB
        MaxSizeMB int `toml:"max_size_mb" json:"max_size_mb"`

        // MaxItems is the maximum number of items to cache
        MaxItems int `toml:"max_items" json:"max_items"`

        // TTLMinutes is the cache TTL in minutes
        TTLMinutes int `toml:"ttl_minutes" json:"ttl_minutes"`
}

// DiskCacheConfig configures disk-based caching
type DiskCacheConfig struct {
        // Enabled turns on/off disk caching
        Enabled bool `toml:"enabled" json:"enabled"`

        // Path is the cache directory
        Path string `toml:"path" json:"path"`

        // MaxSizeMB is the maximum disk cache size in MB
        MaxSizeMB int `toml:"max_size_mb" json:"max_size_mb"`

        // TTLHours is the cache TTL in hours
        TTLHours int `toml:"ttl_hours" json:"ttl_hours"`

        // CleanupIntervalHours is how often to clean expired entries
        CleanupIntervalHours int `toml:"cleanup_interval_hours" json:"cleanup_interval_hours"`
}

// StorageError represents an error from a storage backend
type StorageError struct {
        Backend   StorageType
        Operation string
        Path      string
        Err       error
        Retryable bool
}

func (e *StorageError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("storage error [%s:%s] %s: %v", 
                e.Backend, e.Operation, e.Path, e.Err)
}</span>

func (e *StorageError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

func (e *StorageError) IsRetryable() bool <span class="cov0" title="0">{
        return e.Retryable
}</span>

// NewStorageError creates a new storage error
func NewStorageError(backend StorageType, operation, path string, err error, retryable bool) *StorageError <span class="cov0" title="0">{
        return &amp;StorageError{
                Backend:   backend,
                Operation: operation,
                Path:      path,
                Err:       err,
                Retryable: retryable,
        }
}</span>

// IsNotFound returns true if the error indicates a file was not found
func IsNotFound(err error) bool <span class="cov0" title="0">{
        if storageErr, ok := err.(*StorageError); ok </span><span class="cov0" title="0">{
                return storageErr.Operation == "read" || storageErr.Operation == "stat"
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsRetryable returns true if the error is retryable
func IsRetryable(err error) bool <span class="cov0" title="0">{
        if storageErr, ok := err.(*StorageError); ok </span><span class="cov0" title="0">{
                return storageErr.IsRetryable()
        }</span>
        <span class="cov0" title="0">return false</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package ulid

import (
        "crypto/rand"
        "math"
        "strings"
        "sync"
        "time"

        "github.com/oklog/ulid/v2"
)

// Generator provides thread-safe ULID generation
type Generator struct {
        entropy *ulid.MonotonicEntropy
        mu      sync.Mutex
}

// NewGenerator creates a new ULID generator with cryptographic entropy
func NewGenerator() *Generator <span class="cov3" title="9">{
        entropy := ulid.Monotonic(rand.Reader, 0)
        return &amp;Generator{
                entropy: entropy,
        }
}</span>

// Generate creates a new ULID
func (g *Generator) Generate() string <span class="cov9" title="1007">{
        g.mu.Lock()
        defer g.mu.Unlock()
        
        id := ulid.MustNew(ulid.Timestamp(time.Now()), g.entropy)
        return id.String()
}</span>

// GenerateAt creates a ULID with a specific timestamp
func (g *Generator) GenerateAt(t time.Time) string <span class="cov3" title="9">{
        g.mu.Lock()
        defer g.mu.Unlock()
        
        id := ulid.MustNew(ulid.Timestamp(t), g.entropy)
        return id.String()
}</span>

// GenerateWithPrefix creates a ULID and formats it for file naming
// Returns: "{ulid}.md"
func (g *Generator) GenerateWithPrefix() string <span class="cov1" title="2">{
        id := g.Generate()
        return id + ".md"
}</span>

// Parse parses a ULID string and returns the underlying ULID
func Parse(s string) (ulid.ULID, error) <span class="cov0" title="0">{
        return ulid.Parse(s)
}</span>

// ParseFromFilename extracts ULID from a filename
// Handles both "01ARZ3NDEKTSV4RRFFQ69G5FAV.md" and "01ARZ3NDEKTSV4RRFFQ69G5FAV"
func ParseFromFilename(filename string) (ulid.ULID, error) <span class="cov2" title="4">{
        // Remove .md extension if present
        id := strings.TrimSuffix(filename, ".md")
        return ulid.Parse(id)
}</span>

// ExtractTimestamp extracts the timestamp from a ULID
func ExtractTimestamp(id string) (time.Time, error) <span class="cov3" title="8">{
        parsed, err := ulid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov3" title="8">return time.Unix(0, int64(parsed.Time())*int64(time.Millisecond)), nil</span>
}

// ExtractTimestampFromFilename extracts timestamp from a filename containing ULID
func ExtractTimestampFromFilename(filename string) (time.Time, error) <span class="cov0" title="0">{
        parsed, err := ParseFromFilename(filename)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov0" title="0">return time.Unix(0, int64(parsed.Time())*int64(time.Millisecond)), nil</span>
}

// IsValid checks if a string is a valid ULID
func IsValid(s string) bool <span class="cov10" title="1015">{
        _, err := ulid.Parse(s)
        return err == nil
}</span>

// IsValidFilename checks if a filename contains a valid ULID
func IsValidFilename(filename string) bool <span class="cov3" title="5">{
        id := strings.TrimSuffix(filename, ".md")
        return IsValid(id)
}</span>

// Compare compares two ULIDs lexicographically
// Returns -1 if a &lt; b, 0 if a == b, 1 if a &gt; b
func Compare(a, b string) int <span class="cov1" title="2">{
        return strings.Compare(a, b)
}</span>

// CompareTimestamps compares the timestamps of two ULIDs
// Returns -1 if a is older, 0 if same time, 1 if a is newer
func CompareTimestamps(a, b string) (int, error) <span class="cov0" title="0">{
        timeA, err := ExtractTimestamp(a)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        
        <span class="cov0" title="0">timeB, err := ExtractTimestamp(b)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        
        <span class="cov0" title="0">if timeA.Before(timeB) </span><span class="cov0" title="0">{
                return -1, nil
        }</span> else<span class="cov0" title="0"> if timeA.After(timeB) </span><span class="cov0" title="0">{
                return 1, nil
        }</span>
        <span class="cov0" title="0">return 0, nil</span>
}

// SortByTimestamp sorts ULID strings by their embedded timestamps
func SortByTimestamp(ids []string, ascending bool) []string <span class="cov0" title="0">{
        sorted := make([]string, len(ids))
        copy(sorted, ids)
        
        if ascending </span><span class="cov0" title="0">{
                // ULIDs are naturally sortable in ascending order
                return sorted
        }</span>
        
        // For descending, reverse the slice
        <span class="cov0" title="0">for i := len(sorted)/2 - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                opp := len(sorted) - 1 - i
                sorted[i], sorted[opp] = sorted[opp], sorted[i]
        }</span>
        
        <span class="cov0" title="0">return sorted</span>
}

// TimestampRange represents a time range for filtering ULIDs
type TimestampRange struct {
        Start time.Time
        End   time.Time
}

// FilterByTimeRange filters ULIDs to only include those within the time range
func FilterByTimeRange(ids []string, timeRange TimestampRange) ([]string, error) <span class="cov1" title="1">{
        var filtered []string
        
        for _, id := range ids </span><span class="cov3" title="5">{
                timestamp, err := ExtractTimestamp(id)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid ULIDs
                }
                
                <span class="cov3" title="5">if (timeRange.Start.IsZero() || timestamp.After(timeRange.Start) || timestamp.Equal(timeRange.Start)) &amp;&amp;
                   (timeRange.End.IsZero() || timestamp.Before(timeRange.End) || timestamp.Equal(timeRange.End)) </span><span class="cov2" title="3">{
                        filtered = append(filtered, id)
                }</span>
        }
        
        <span class="cov1" title="1">return filtered, nil</span>
}

// GetTimeFromULID extracts time.Time from ULID string with error handling
func GetTimeFromULID(id string) (time.Time, error) <span class="cov0" title="0">{
        return ExtractTimestamp(id)
}</span>

// GetDayFromULID extracts the date (YYYY-MM-DD) from a ULID
func GetDayFromULID(id string) (string, error) <span class="cov0" title="0">{
        timestamp, err := ExtractTimestamp(id)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return timestamp.Format("2006-01-02"), nil</span>
}

// IsFromToday checks if a ULID was created today
func IsFromToday(id string) (bool, error) <span class="cov0" title="0">{
        timestamp, err := ExtractTimestamp(id)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        
        <span class="cov0" title="0">now := time.Now()
        return timestamp.Year() == now.Year() &amp;&amp; 
                   timestamp.YearDay() == now.YearDay(), nil</span>
}

// IsFromDate checks if a ULID was created on a specific date
func IsFromDate(id string, date time.Time) (bool, error) <span class="cov0" title="0">{
        timestamp, err := ExtractTimestamp(id)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        
        <span class="cov0" title="0">return timestamp.Year() == date.Year() &amp;&amp; 
                   timestamp.YearDay() == date.YearDay(), nil</span>
}

// AgeInDays returns how many days old a ULID is
func AgeInDays(id string) (int, error) <span class="cov1" title="1">{
        timestamp, err := ExtractTimestamp(id)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        
        <span class="cov1" title="1">duration := time.Since(timestamp)
        return int(math.Floor(duration.Hours() / 24)), nil</span>
}

// ToFilename converts a ULID to a filename format
func ToFilename(id string) string <span class="cov0" title="0">{
        if !strings.HasSuffix(id, ".md") </span><span class="cov0" title="0">{
                return id + ".md"
        }</span>
        <span class="cov0" title="0">return id</span>
}

// FromFilename extracts ULID from filename format
func FromFilename(filename string) string <span class="cov0" title="0">{
        return strings.TrimSuffix(filename, ".md")
}</span>

// Validate performs comprehensive validation on a ULID string
func Validate(id string) error <span class="cov3" title="6">{
        if id == "" </span><span class="cov1" title="1">{
                return NewULIDError("ULID cannot be empty")
        }</span>
        
        <span class="cov3" title="5">if len(id) != 26 </span><span class="cov2" title="3">{
                return NewULIDError("ULID must be exactly 26 characters long")
        }</span>
        
        <span class="cov1" title="2">if _, err := ulid.Parse(id); err != nil </span><span class="cov0" title="0">{
                return NewULIDError("invalid ULID format: " + err.Error())
        }</span>
        
        <span class="cov1" title="2">return nil</span>
}

// ValidateFilename validates a filename containing a ULID
func ValidateFilename(filename string) error <span class="cov2" title="4">{
        if filename == "" </span><span class="cov1" title="1">{
                return NewULIDError("filename cannot be empty")
        }</span>
        
        <span class="cov2" title="3">if !strings.HasSuffix(filename, ".md") </span><span class="cov1" title="1">{
                return NewULIDError("filename must have .md extension")
        }</span>
        
        <span class="cov1" title="2">id := strings.TrimSuffix(filename, ".md")
        return Validate(id)</span>
}

// ULIDError represents an error related to ULID operations
type ULIDError struct {
        Message string
}

func (e *ULIDError) Error() string <span class="cov0" title="0">{
        return "ULID error: " + e.Message
}</span>

// NewULIDError creates a new ULID error
func NewULIDError(message string) *ULIDError <span class="cov3" title="6">{
        return &amp;ULIDError{Message: message}
}</span>

// Global generator instance for convenience
var defaultGenerator = NewGenerator()

// New generates a new ULID using the default generator
func New() string <span class="cov1" title="1">{
        return defaultGenerator.Generate()
}</span>

// NewWithTimestamp generates a new ULID with a specific timestamp
func NewWithTimestamp(t time.Time) string <span class="cov1" title="1">{
        return defaultGenerator.GenerateAt(t)
}</span>

// NewFilename generates a new ULID filename
func NewFilename() string <span class="cov1" title="1">{
        return defaultGenerator.GenerateWithPrefix()
}</pre>
		
		<pre class="file" id="file6" style="display: none">package ulid

import (
        "fmt"
        "regexp"
        "strings"
        "time"

        "github.com/oklog/ulid/v2"
)

var (
        // ULID regex pattern: 26 characters, Crockford's Base32 alphabet
        // 01ARZ3NDEKTSV4RRFFQ69G5FAV
        ulidPattern = regexp.MustCompile(`^[0-7][0-9A-HJKMNP-TV-Z]{25}$`)
        
        // Filename pattern: ULID + .md extension
        filenamePattern = regexp.MustCompile(`^[0-7][0-9A-HJKMNP-TV-Z]{25}\.md$`)
)

// ValidationResult contains the result of ULID validation
type ValidationResult struct {
        IsValid   bool                   `json:"is_valid"`
        Errors    []string               `json:"errors,omitempty"`
        Warnings  []string               `json:"warnings,omitempty"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// Validator provides comprehensive ULID validation
type Validator struct {
        strictMode bool
}

// NewValidator creates a new ULID validator
func NewValidator(strictMode bool) *Validator <span class="cov10" title="2">{
        return &amp;Validator{
                strictMode: strictMode,
        }
}</span>

// ValidateString performs comprehensive validation on a ULID string
func (v *Validator) ValidateString(id string) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{
                IsValid:  true,
                Metadata: make(map[string]interface{}),
        }

        // Basic checks
        if id == "" </span><span class="cov0" title="0">{
                result.IsValid = false
                result.Errors = append(result.Errors, "ULID cannot be empty")
                return result
        }</span>

        <span class="cov0" title="0">if len(id) != 26 </span><span class="cov0" title="0">{
                result.IsValid = false
                result.Errors = append(result.Errors, "ULID must be exactly 26 characters long")
                return result
        }</span>

        // Pattern check
        <span class="cov0" title="0">if !ulidPattern.MatchString(id) </span><span class="cov0" title="0">{
                result.IsValid = false
                result.Errors = append(result.Errors, "ULID contains invalid characters")
                return result
        }</span>

        // Parse check
        <span class="cov0" title="0">parsed, err := ulid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                result.IsValid = false
                result.Errors = append(result.Errors, "invalid ULID format: "+err.Error())
                return result
        }</span>

        // Extract metadata
        <span class="cov0" title="0">timestamp, _ := ExtractTimestamp(id)
        result.Metadata["timestamp"] = timestamp
        result.Metadata["timestamp_unix"] = timestamp.Unix()
        result.Metadata["age_hours"] = int(timestamp.Sub(timestamp).Hours())

        // Strict mode checks
        if v.strictMode </span><span class="cov0" title="0">{
                v.performStrictChecks(id, parsed, result)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateFilename validates a filename containing a ULID
func (v *Validator) ValidateFilename(filename string) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{
                IsValid:  true,
                Metadata: make(map[string]interface{}),
        }

        if filename == "" </span><span class="cov0" title="0">{
                result.IsValid = false
                result.Errors = append(result.Errors, "filename cannot be empty")
                return result
        }</span>

        // Check extension
        <span class="cov0" title="0">if !strings.HasSuffix(filename, ".md") </span><span class="cov0" title="0">{
                if v.strictMode </span><span class="cov0" title="0">{
                        result.IsValid = false
                        result.Errors = append(result.Errors, "filename must have .md extension")
                        return result
                }</span> else<span class="cov0" title="0"> {
                        result.Warnings = append(result.Warnings, "filename should have .md extension")
                }</span>
        }

        // Pattern check
        <span class="cov0" title="0">if strings.HasSuffix(filename, ".md") &amp;&amp; !filenamePattern.MatchString(filename) </span><span class="cov0" title="0">{
                result.IsValid = false
                result.Errors = append(result.Errors, "filename contains invalid ULID")
                return result
        }</span>

        // Extract and validate ULID
        <span class="cov0" title="0">id := strings.TrimSuffix(filename, ".md")
        ulidResult := v.ValidateString(id)
        
        if !ulidResult.IsValid </span><span class="cov0" title="0">{
                result.IsValid = false
                result.Errors = append(result.Errors, ulidResult.Errors...)
        }</span>
        
        <span class="cov0" title="0">result.Warnings = append(result.Warnings, ulidResult.Warnings...)
        
        // Copy metadata
        for k, v := range ulidResult.Metadata </span><span class="cov0" title="0">{
                result.Metadata[k] = v
        }</span>
        
        <span class="cov0" title="0">result.Metadata["filename"] = filename
        result.Metadata["extracted_ulid"] = id

        return result</span>
}

// ValidateBatch validates multiple ULIDs and returns summary statistics
func (v *Validator) ValidateBatch(ids []string) *BatchValidationResult <span class="cov0" title="0">{
        result := &amp;BatchValidationResult{
                Total:   len(ids),
                Valid:   0,
                Invalid: 0,
                Results: make(map[string]*ValidationResult),
        }

        for _, id := range ids </span><span class="cov0" title="0">{
                validation := v.ValidateString(id)
                result.Results[id] = validation
                
                if validation.IsValid </span><span class="cov0" title="0">{
                        result.Valid++
                }</span> else<span class="cov0" title="0"> {
                        result.Invalid++
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// BatchValidationResult contains results for batch validation
type BatchValidationResult struct {
        Total   int                           `json:"total"`
        Valid   int                           `json:"valid"`
        Invalid int                           `json:"invalid"`
        Results map[string]*ValidationResult `json:"results"`
}

// GetInvalidULIDs returns a list of invalid ULIDs from batch validation
func (r *BatchValidationResult) GetInvalidULIDs() []string <span class="cov0" title="0">{
        var invalid []string
        for id, result := range r.Results </span><span class="cov0" title="0">{
                if !result.IsValid </span><span class="cov0" title="0">{
                        invalid = append(invalid, id)
                }</span>
        }
        <span class="cov0" title="0">return invalid</span>
}

// GetValidULIDs returns a list of valid ULIDs from batch validation
func (r *BatchValidationResult) GetValidULIDs() []string <span class="cov0" title="0">{
        var valid []string
        for id, result := range r.Results </span><span class="cov0" title="0">{
                if result.IsValid </span><span class="cov0" title="0">{
                        valid = append(valid, id)
                }</span>
        }
        <span class="cov0" title="0">return valid</span>
}

// performStrictChecks performs additional validation in strict mode
func (v *Validator) performStrictChecks(id string, parsed ulid.ULID, result *ValidationResult) <span class="cov0" title="0">{
        timestamp := time.Unix(0, int64(parsed.Time())*int64(time.Millisecond))
        now := time.Now()

        // Check if timestamp is in the future
        if timestamp.After(now.Add(time.Minute)) </span><span class="cov0" title="0">{ // Allow 1 minute tolerance
                result.Warnings = append(result.Warnings, "ULID timestamp is in the future")
        }</span>

        // Check if timestamp is too old (more than 10 years)
        <span class="cov0" title="0">if timestamp.Before(now.Add(-10 * 365 * 24 * time.Hour)) </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, "ULID timestamp is very old (&gt;10 years)")
        }</span>

        // Check for potential collision (same millisecond)
        // This is more of an informational warning
        <span class="cov0" title="0">if timestamp.UnixMilli() == now.UnixMilli() </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, "ULID generated in current millisecond (potential collision)")
        }</span>
}

// FixCommonIssues attempts to fix common ULID formatting issues
func FixCommonIssues(input string) (string, []string) <span class="cov0" title="0">{
        var fixes []string
        fixed := input

        // Remove common prefixes/suffixes
        if strings.HasPrefix(fixed, "ulid:") </span><span class="cov0" title="0">{
                fixed = strings.TrimPrefix(fixed, "ulid:")
                fixes = append(fixes, "removed 'ulid:' prefix")
        }</span>

        // Trim whitespace
        <span class="cov0" title="0">trimmed := strings.TrimSpace(fixed)
        if trimmed != fixed </span><span class="cov0" title="0">{
                fixed = trimmed
                fixes = append(fixes, "trimmed whitespace")
        }</span>

        // Convert to uppercase (ULIDs should be uppercase)
        <span class="cov0" title="0">upper := strings.ToUpper(fixed)
        if upper != fixed </span><span class="cov0" title="0">{
                fixed = upper
                fixes = append(fixes, "converted to uppercase")
        }</span>

        // Remove .md extension if present during validation
        <span class="cov0" title="0">if strings.HasSuffix(fixed, ".md") </span><span class="cov0" title="0">{
                withoutExt := strings.TrimSuffix(fixed, ".md")
                if IsValid(withoutExt) </span><span class="cov0" title="0">{
                        // Don't modify the fixed value, just note it
                        fixes = append(fixes, "note: .md extension detected (valid for filename)")
                }</span>
        }

        <span class="cov0" title="0">return fixed, fixes</span>
}

// SuggestCorrections suggests possible corrections for invalid ULIDs
func SuggestCorrections(input string) []string <span class="cov0" title="0">{
        var suggestions []string

        // Try fixing common issues first
        fixed, fixes := FixCommonIssues(input)
        if len(fixes) &gt; 0 &amp;&amp; IsValid(fixed) </span><span class="cov0" title="0">{
                suggestions = append(suggestions, "Try: "+fixed+" ("+strings.Join(fixes, ", ")+")")
        }</span>

        // Check length and suggest padding/truncation
        <span class="cov0" title="0">if len(fixed) &lt; 26 </span><span class="cov0" title="0">{
                suggestions = append(suggestions, "ULID is too short (need "+fmt.Sprintf("%d", 26-len(fixed))+" more characters)")
        }</span> else<span class="cov0" title="0"> if len(fixed) &gt; 26 </span><span class="cov0" title="0">{
                suggestions = append(suggestions, "ULID is too long (remove "+fmt.Sprintf("%d", len(fixed)-26)+" characters)")
        }</span>

        // Check for invalid characters
        <span class="cov0" title="0">invalidChars := findInvalidCharacters(fixed)
        if len(invalidChars) &gt; 0 </span><span class="cov0" title="0">{
                suggestions = append(suggestions, "Contains invalid characters: "+strings.Join(invalidChars, ", "))
                suggestions = append(suggestions, "Valid characters: 0-9, A-Z (excluding I, L, O, U)")
        }</span>

        // Suggest generating a new ULID if all else fails
        <span class="cov0" title="0">if !IsValid(fixed) </span><span class="cov0" title="0">{
                suggestions = append(suggestions, "Consider generating a new ULID: "+New())
        }</span>

        <span class="cov0" title="0">return suggestions</span>
}

// findInvalidCharacters returns characters that are not valid in a ULID
func findInvalidCharacters(input string) []string <span class="cov0" title="0">{
        validChars := "0123456789ABCDEFGHJKMNPQRSTVWXYZ"
        var invalid []string
        seen := make(map[rune]bool)

        for _, char := range input </span><span class="cov0" title="0">{
                if !strings.ContainsRune(validChars, char) &amp;&amp; !seen[char] </span><span class="cov0" title="0">{
                        invalid = append(invalid, string(char))
                        seen[char] = true
                }</span>
        }

        <span class="cov0" title="0">return invalid</span>
}

// Global validator instances
var (
        standardValidator = NewValidator(false)
        strictValidator   = NewValidator(true)
)

// Quick validation functions using global validators

// QuickValidate performs standard validation on a ULID string
func QuickValidate(id string) bool <span class="cov0" title="0">{
        return standardValidator.ValidateString(id).IsValid
}</span>

// QuickValidateStrict performs strict validation on a ULID string
func QuickValidateStrict(id string) bool <span class="cov0" title="0">{
        return strictValidator.ValidateString(id).IsValid
}</span>

// QuickValidateFilename performs standard validation on a filename
func QuickValidateFilename(filename string) bool <span class="cov0" title="0">{
        return standardValidator.ValidateFilename(filename).IsValid
}</span>

// QuickValidateFilenameStrict performs strict validation on a filename
func QuickValidateFilenameStrict(filename string) bool <span class="cov0" title="0">{
        return strictValidator.ValidateFilename(filename).IsValid
}</span>

// DetailedValidate returns full validation details for a ULID
func DetailedValidate(id string) *ValidationResult <span class="cov0" title="0">{
        return standardValidator.ValidateString(id)
}</span>

// DetailedValidateStrict returns full strict validation details for a ULID
func DetailedValidateStrict(id string) *ValidationResult <span class="cov0" title="0">{
        return strictValidator.ValidateString(id)
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
